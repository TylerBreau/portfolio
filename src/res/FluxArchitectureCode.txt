interface IActionData<TData = unknown> {
    getTag(): string;
    getData(): TData;
}
interface IDispatcher {
    dispatch(data: IActionData): void;
    register(id: string, callback: (data: IActionData) => void): void;
    unregister(id: string): void;
}
interface IAction<TKWArgs = void, TResponse = void> {
    getTag(): string;
    execute(kwargs: TKWArgs): Promise<TResponse>;
    checkType(ad: IActionData<unknown>): ad is IActionData<TResponse>;
}
interface IStore {
    register(callback: () => void): void;
    unregister(callback: () => void): void;
}

import React from 'react';
interface IEventsScreenState {
    events: string[];
}
class EventsScreen extends React.Component<{}, IEventsScreenState> {
    public constructor(props: {}) {
        super(props);

        this.state = {
            events: EventStore.getInstance().getEvents()
        };

        this._onEventsStoreUpdate = this._onEventsStoreUpdate.bind(this);
    }

    componentDidMount(): void {
        EventStore.getInstance().register(this._onEventsStoreUpdate);    

        new LoadEventsAction().execute();
    }

    componentWillUnmount(): void {
        EventStore.getInstance().unregister(this._onEventsStoreUpdate);
    }

    protected _onEventsStoreUpdate(): void {
        this.setState({
            events: EventStore.getInstance().getEvents()
        });
    }

    render() {
        return <ul>
        {
            this.state.events.map((event: string) => {
                return <li>{event}</li>;
            })
        }
        </ul>
    }
}

abstract class Action<TArgs = void, TResponse = void> implements IAction<TArgs, TResponse> {
    public abstract getTag(): string;

    /**
        * 
        * Checks if ActionData was produced by an Action of this type.
        * If it was, it would be type of ActionData<TResponse> and the type is narrowed down for typescript.
        * 
        * @param ad ActionData received from the Dispatcher
        * @returns TypeScript Predicate
        */
    public checkType(ad: IActionData): ad is IActionData<TResponse> {
        return ad.getTag() === this.getTag();
    }

    protected _dispatch(data: TResponse) {
        Dispatcher.getInstance().dispatch(new ActionData(this.getTag(), data));
    }

    public execute(args: TArgs): Promise<TResponse> {
        return this._execute(args).then((result) => {
            this._dispatch(result);
            return Promise.resolve(result);
        });
    }

    protected abstract _execute(args: TArgs): Promise<TResponse>;
}
class LoadEventsAction extends Action<void, string[]> {
    public getTag(): string {
        return 'load-events';
    }

    protected _execute(): Promise<string[]> {
        // HTTP Request to server to get event list
        // We're just going to dummy it out.
        return Promise.resolve([
            "event 1",
            "event 2",
            "event 3"
        ]);
    }
}


class ActionData<TData = unknown> implements IActionData<TData> {
    private $tag: string;
    private $data: any;

    public constructor(tag: string, data: TData) {
        this.$tag = tag;
        this.$data = data;
    }

    public getTag(): string {
        return this.$tag;
    }

    public getData(): TData {
        return this.$data;
    }
}

import { v4 as uuidv4 } from 'uuid';
class Dispatcher {
    private $callbacks: Record<string, (data: IActionData) => void>;

    private static $instance: Dispatcher;

    private constructor() {
        this.$callbacks = {};
    }

    public static getInstance(): Dispatcher {
        if (!Dispatcher.$instance) {
            Dispatcher.$instance = new Dispatcher();
        }

        return Dispatcher.$instance;
    }

    public dispatch(data: IActionData): void {
        for (let i in this.$callbacks) {
            this.$callbacks[i](data);
        }
    }

    /**
        * 
        * @param id Must not already be registered.
        * @param callback 
        * @returns 
        */
    public register(id: string, callback: (data: IActionData) => void): string {
        if (this.$callbacks[id]) {
            throw new Error('Duplicater register for id: ' + id)
        }
        this.$callbacks[id] = callback;
        return id;
    }

    public unregister(id: string): void {
        delete this.$callbacks[id];
    }
}

import { EventEmitter } from 'events';
abstract class Store extends EventEmitter implements IStore {
    public constructor() {
        super();
        this.setMaxListeners(100);
        Dispatcher.getInstance().register(this._getStoreName(), (data: IActionData) => {
            if (this._update(data)) {
                this.$onUpdate();
            }
        });
    }

    protected abstract _getStoreName(): string;

    public register(callback: () => void): void {
        this.on('update', callback);
    }

    public unregister(callback: () => void): void {
        this.removeListener('update', callback);
    }

    private $onUpdate(): void {
        this.emit('update');
    }

    protected abstract _update(data: IActionData): boolean;
}
class EventStore extends Store {
    private $events: string[];
    private static $instance: EventStore;

    public constructor() {
        super();
        this.$events = [];
    }

    public static getInstance(): EventStore {
        if (!EventStore.$instance) {
            EventStore.$instance = new EventStore();
        }
        return EventStore.$instance;
    }

    protected _getStoreName() {
        return 'EventStore';
    }

    protected _update(data: IActionData): boolean {
        if (new LoadEventsAction().checkType(data)) {
            // The checkType predicate narrows down data's typings, so typescript doesn't complain here.
            this.$events = data.getData();
            return true;
        }

        return false;
    }

    public getEvents(): string[] {
        return this.$events;
    }
}